# Golang 中的Context

## 参考列表：

https://zhuanlan.zhihu.com/p/68792989

http://c.biancheng.net/view/5714.html

https://segmentfault.com/a/1190000022887010



在Go1.7之后，进入Go语言标准库中，准确的说是Goroutine的上下文，包含Goroutine的运行状态、环境、现场等信息。

## 什么是Context

"上下文"？很直接的一个表达，但是也很抽象。对于有开发经验的小伙伴可能能理出来其实是**一种状态**信息 的持有。比较术语的解释：程序单元的一个运行状态、现场、快照。其中上下是指存在上下层的传递，上会把内容传递给下，程序单元指的是Goroutine。



每个Goroutine在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个Context变量中，传递给要执行的Goroutine中；



## 为什么需要Context

Go 常用来写后台服务，通常只需要几行代码，就可以搭建一个 http server。

在 Go 的 server 里，通常每来一个请求都会启动若干个 goroutine 同时工作：有些去数据库拿数据，有些调用下游接口获取相关数据……

![](https://pic2.zhimg.com/80/v2-f028da2b74c2ed08718d206c74cc6a9d_720w.jpg)

这些 goroutine 需要共享这个请求的基本数据，例如登陆的 token，处理请求的最大超时时间（如果超过此值再返回数据，请求方因为超时接收不到）等等。当请求被取消或是处理时间太长，这有可能是使用者关闭了浏览器或是已经超过了请求方规定的超时时间，请求方直接放弃了这次请求结果。这时，所有正在为这个请求工作的 goroutine 需要快速退出，因为它们的“工作成果”不再被需要了。在相关联的 goroutine 都退出后，系统就可以回收相关的资源。

再多说一点，Go 语言中的 server 实际上是一个“协程模型”，也就是说一个协程处理一个请求。例如在业务的高峰期，某个下游服务的响应变慢，而当前系统的请求又没有超时控制，或者超时时间设置地过大，那么等待下游服务返回数据的协程就会越来越多。而我们知道，协程是要消耗系统资源的，后果就是协程数激增，内存占用飙涨，甚至导致服务不可用。更严重的会导致雪崩效应，整个服务对外表现为不可用，这肯定是 P0 级别的事故。这时，肯定有人要背锅了。

## 使用示例





## 源码



